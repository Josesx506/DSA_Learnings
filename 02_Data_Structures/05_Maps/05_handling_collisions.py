'''
Collision Handling

As discussed earlier, when two different inputs produce the same output, then we have a collision. 
Our implementation of get_hash_code() function is satisfactory. However, because we are using 
compression function, we are prone to collisions. Remember, that a key will always be unique. 
But the bucket_index generated by two different keys can be the same.

Consider the following scenario - We have a bucket array of length 10 and we get two different hash 
codes for two different inputs, say 355, and 1095. Even though the hash codes are different in this 
case, the bucket index will be same because of the way we have implemented our compression function. 
Such scenarios where multiple entries want to go to the same bucket are very common. So, we introduce 
some logic to handle collisions.

There are two popular ways in which we handle collisions.
    1. Separate chaining - Separate chaining is a clever technique where we use the same bucket to store 
    multiple objects. The bucket in this case will store a linked list of key-value pairs. Every 
    bucket has it's own separate chain of linked list nodes.

    2. Open Addressing - In open addressing, we do the following:
        - If, after getting the bucket index, the bucket is empty, we store the object in that particular bucket
        - If the bucket is not empty, we find an alternate bucket index by using another function which modifies 
        the current hash code to give a new code. This process of finding an alternate bucket index is called 
        probing. A few probing techniques are - linear probing, qudratic probing, or double hashing.

Separate chaining is a simple and effective technique to handle collisions and that is what we discuss here. 
Let's implement the put and get function using the idea of separate chaining.
'''

class LinkedListNode:
    
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

class HashMap:
    
    def __init__(self, initial_size = 10):
        self.bucket_array = [None for _ in range(initial_size)]
        self.p = 31
        self.num_entries = 0
    
    '''
    Separate chaining:
    In case of collision, the `put()` function uses the same bucket to store a linked list of key-value pairs. 
    Every bucket will have it's own separate chain of linked list nodes.
    '''  
    def put(self, key: str, value: int):
        '''
        Args
            Key is a string
            Value is numeric
        '''
        # Apply the hash function and calculate the table index of the provided key
        bucket_index = self.get_bucket_index(key)   

        # Create a node
        new_node = LinkedListNode(key, value)  

        # Create a reference that points to the existing bucket at position bucket_index                     
        head = self.bucket_array[bucket_index]

        '''
        Check if key is already present in the map, and UPDATE it's value 
        Remember, a key should always be unique.
        ''' 
        while head is not None:
            if head.key == key:
                head.value = value
                return
            head = head.next
        
        '''
        If the key is a new one, hence not found in the chain (LinkedList), then following two cases arise:
         1. The key has generated a new bucket_index
         2. The key has generated an existing bucket_index. 
            This event is a Collision, i.e., two different keys have same bucket_index.

        In both the cases, we will prepend the new node (key, value) at the beginning (head) of the chain (LinkedList).
        Remember that each `bucket` at position `bucket_index` is actually a chain (LinkedList) with 1 or more nodes.  
        '''
        head = self.bucket_array[bucket_index]
        new_node.next = head                                         
        self.bucket_array[bucket_index] = new_node                  # Prepend the new node in the beginning of the linked list
        self.num_entries += 1
        
    def get(self, key):
        bucket_index = self.get_bucket_index(key) 
        head = self.bucket_array[bucket_index]
        while head is not None:
            if head.key == key:
                return head.value
            head = head.next
        return None
        
    def get_bucket_index(self, key):
        bucket_index = self.get_hash_code(key)
        return bucket_index
    
    def get_hash_code(self, key):
        key = str(key)
        num_buckets = len(self.bucket_array)
        current_coefficient = 1
        hash_code = 0
        for character in key:
            hash_code += ord(character) * current_coefficient
            hash_code = hash_code % num_buckets                       # compress hash_code
            current_coefficient *= self.p
            current_coefficient = current_coefficient % num_buckets   # compress coefficient

        return hash_code % num_buckets                                # one last compression before returning
    
    def size(self):
        return self.num_entries
    
    # Helper function to see the hashmap
    def __repr__(self):
        output = "\nLet's view the hash map:"

        node = self.bucket_array
        for bucket_index, node in enumerate(self.bucket_array):
            if node is None:
                output += '\n[{}] '.format(bucket_index)
            else:
                output += '\n[{}]'.format(bucket_index)
                while node is not None:
                    output += ' ({} , {}) '.format(node.key, node.value)
                    if node.next is not None:
                        output += ' --> '
                    node = node.next
                    
        return output


# Test the collision resolution technique
hash_map = HashMap()

hash_map.put("one", 1)
hash_map.put("two", 2)
hash_map.put("three", 3)          # Collision: The key "three" will generate the same bucket_index as that of the key "two"
hash_map.put("neo", 11)           # Collision: The key "neo" will generate the same bucket_index as that of the key "one"

print("size: {}".format(hash_map.size()))

print("one: {}".format(hash_map.get("one")))
print("neo: {}".format(hash_map.get("neo")))
print("three: {}".format(hash_map.get("three")))

print(hash_map)                          # call to the helper function to see the hashmap